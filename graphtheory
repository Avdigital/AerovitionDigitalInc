/* 161 *Datastructure definition of "-link" 162 *NETWORK GRAPH DEFINITION & LOGIC 163 *angularJS, MIT lisneced. 164 *Subject to change and modification 165 */ 166 class Unit { 167  168   // Entity is used as node or edge type, for different classifications 169   //    i.e. 'person', 'game', 'road', etc. 170   constructor(entity, properties) { 171  172     this.entity = entity + ''; 173  174     this.load(properties || {}); 175  176   } 177  178   // load properties (id, name, age, etc.) from an object 179   load(properties) { 180  181     let p = Object.create(null); 182  183     Object.keys(properties).forEach(function(v) { 184  185       p[v] = properties[v]; 186  187     }); 188  189     this.properties = p; 190  191     return this; 192  193   } 194  195   set(property, value) { 196  197     return this.properties[property] = value; 198  199   } 200  201   unset(property) { 202  203     return delete this.properties[property]; 204  205   } 206  207   has(property) { 208  209     return Object.prototype.hasOwnProperty.call(this.properties, property); 210  211   } 212  213   get(property) { 214  215     return this.properties[property]; 216  217   } 218  219   toString() { 220  221     return [this.constructor.name, ' (', this.entity, ' ', JSON.stringify(this.properties) ,')'].join(''); 222  223   } 224  225 } 226 /* 227 *Defintin of ulink 228 * 229 */ 230 class Node extends Unit { 231  232   constructor(entity, properties) { 233  234     super(entity, properties); 235     this.edges = []; 236     this.inputEdges = []; 237     this.outputEdges = []; 238  239   } 240  241   unlink() { 242  243     let edges = this.edges; 244  245     for (let i = 0, len = edges.length; i < len; i++) { 246       edges[i].unlink(); 247     } 248  249     return true; 250  251   } 252  253 } 254  255 /* 256 * 257 Function to include in our Edge that takes care of connecting  258 nodes to one another.  259 In this edge we hold an inputNode, an outputNode and whether  260 or not the edge is a duplex link (bi-directional). 261 */ 262 class Edge extends Unit { 263  264   constructor(entity, properties) { 265  266     super(entity, properties); 267  268     this.inputNode = null; 269     this.outputNode = null; 270     this.duplex = false; 271  272     this.distance = 1; 273  274   } 275  276   // link a specific node in a certain direction 277   _linkTo(node, direction) { 278  279     if (direction <= 0) { 280       node.inputEdges.push(this); 281     } 282  283     if (direction >= 0) { 284       node.outputEdges.push(this); 285     } 286  287     node.edges.push(this); 288  289     return true; 290  291   } 292  293   // link two nodes, optionally make edge bidirectional (duplex) 294   link(inputNode, outputNode, duplex) { 295  296     this.unlink(); 297  298     this.inputNode = inputNode; 299     this.outputNode = outputNode; 300     this.duplex = !!duplex; 301  302     if (duplex) { 303       this._linkTo(inputNode, 0); 304       this._linkTo(outputNode, 0); 305       return this; 306     } 307  308     this._linkTo(inputNode, 1); 309     this._linkTo(outputNode, -1); 310     return this; 311  312   } 313  314   // distance for traversal 315   setDistance(v) { 316     this.distance = Math.abs(parseFloat(v) || 0); 317     return this; 318   } 319  320   // weight is 1 / distance 321   setWeight(v) { 322     this.distance = 1 / Math.abs(parseFloat(v) || 0); 323     return this; 324   } 325  326   // find the opposite node given a starting node 327   oppositeNode(node) { 328  329     if (this.inputNode === node) { 330       return this.outputNode; 331     } else if (this.outputNode === node) { 332       return this.inputNode; 333     } 334  335     return; 336  337   } 338  339   // unlink edge, remove connections from nodes 340   unlink() { 341  342     let pos; 343     let inode = this.inputNode; 344     let onode = this.outputNode; 345  346     if (!(inode && onode)) { 347       return; 348     } 349  350     (pos = inode.edges.indexOf(this)) > -1 && inode.edges.splice(pos, 1); 351     (pos = onode.edges.indexOf(this)) > -1 && onode.edges.splice(pos, 1); 352     (pos = inode.outputEdges.indexOf(this)) > -1 && inode.outputEdges.splice(pos, 1); 353     (pos = onode.inputEdges.indexOf(this)) > -1 && onode.inputEdges.splice(pos, 1); 354  355     if (this.duplex) { 356  357       (pos = inode.inputEdges.indexOf(this)) > -1 && inode.inputEdges.splice(pos, 1); 358       (pos = onode.outputEdges.indexOf(this)) > -1 && onode.outputEdges.splice(pos, 1); 359  360     } 361  362     this.inputNode = null; 363     this.outputNode = null; 364  365     this.duplex = false; 366  367     return true; 368  369   } 370  371 } 372 /* 373 * 374 Re-implementing our Graph 375 We can now re-implement our “Joe likes Minecraft” graph as follows: 376 * 377 * 378 / 379 // Create nodes... 380 let joe = new Node('person'); 381 joe.set('name', 'Joe'); 382  383 let minecraft = new Node('game'); 384 minecraft.set('name', 'Minecraft'); 385  386 // Create edge... 387 let likes = new Edge('likes'); 388  389 // link 'em! 390 likes.link(joe, minecraft); 391  392 // add more nodes... 393 let notch = new Node('person', {name: 'Notch'}); 394 let created = new Edge('created').link(notch, minecraft); 395  396 /* 397 * 398 We added a bit, so the graph now looks something like: 399 N[Joe] : E[likes] → N[Minecraft] ← E[created] : N[Notch] 400 We can increase the complexity of our graph (so it isn’t just linear!) as much as we want. 401 */ 402  403 // Add even more nodes 404 let mojang = new Node('company', {name: 'Mojang'}); 405 let microsoft = new Node('company', {name: 'Microsoft'}); 406 let jennifer = new Node('person', {name: 'Jennifer'}); 407  408 new Edge('founded').link(notch, mojang); 409 new Edge('acquired').link(microsoft, mojang); 410 new Edge('purchased').link(jennifer, minecraft); 411 new Edge('prints_money_for').link(minecraft, microsoft); 412  413 /* 414  415   Our new graph... 416  417                     Jennifer 418                        | (purchased) 419                        v 420   Joe --(likes)--> Minecraft <--(created)-- Notch 421     (prints_money_for) |                      | (founded) 422                        v                      v 423                    Microsoft --(acquired)--> Mojang 424  425 */ 426  427 /* 428 * 429 /* 430 Mapping User Behavior 431 Now that we have the basic data structures of our graph set up,  432 let’s map our users’ behavior on to a graph. At Storefront, 433 we have at least three basic ways user can interact with a 434 listing: they can A) view a listing, B) favorite a  435 listing or C) request to book a listing. We’ll use  436 these three actions as our edges, and we’ll define  437 two node types, user and listing. 438 We can assemble our graph like so: 439 */ 440 let users = getUsers();         // abstract function to get user data (i.e. SQL) 441 let listings = getListings();   // ... listings 442 let views = getViews();         // ... etc. 443 let favorites = getFavorites(); 444 let requests = getRequests(); 445  446 // quick and dirty O(n) function to get a node by id 447 function getNodeById(nodes, id) { 448   return nodes.filter(function(node) { 449     return node.get('id') === id; 450   })[0]; 451 } 452  453 users = users.map(function(user) { 454   return new Node('user', user); 455 }); 456  457 listings = listings.map(function(listing) { 458   return new Node('listing', listing); 459 }); 460  461 views = views.map(function(view) { 462   return new Edge('view') 463     .link(getNodeById(users, view.user_id), getNodeById(listings, view.listing_id)); 464 }); 465  466 favorites = favorites.map(function(favorite) { 467   return new Edge('favorite') 468     .link(getNodeById(users, favorite.user_id), getNodeById(listings, favorite.listing_id)); 469 }); 470  471 requests = requests.map(function(request) { 472   return new Edge('request') 473     .link(getNodeById(users, request.user_id), getNodeById(listings, request.listing_id)); 474 }); 475  476 /* 477 * 478 graph is represented entirely in memory (RAM). For  479 very large user bases (and large numbers of actions)  480 this can be quite a memory hog. You can decrease the  481 memory space by grouping all actions of a  482 certain type between a user and a listing into a  483 single edge, and ignoring users who haven’t performed  484 actions on your website. 485 == 486 to start giving out recommendations, we need to assign  487 weights (or distances) to each of our user behaviors.  488 We want more important actions to be weighted more favorably.  489 The reason why will become clear when we put everything together.  490 “Weight” and “distance” are inverses of each other, with a  491 higher weight equating to a lower distance. 492 We’ll deal with setting distances because they’re easier  493 to reason about when traversing graphs. Since requests  494 are the most important, we’ll set them to a  495 distance of 1, favorites to 2, and views to 4. 496 */ 497 views.forEach(function(view) { 498   view.setDistance(4); 499 }); 500  501 favorites.forEach(function(favorite) { 502   favorite.setDistance(2); 503 }); 504  505 requests.forEach(function(request) { 506   request.setDistance(1); 507 }); 508  509 /* 510 *Final Impelemation 511 * 512 */ 513 let ug = require('ug'); 514  515 let graph = new ug.Graph(); 516  517 // fetch data 518  519 let users = getUsers();         // abstract function to get user data (i.e. SQL) 520 let listings = getListings();   // ... listings 521 let views = getViews();         // ... etc. 522 let favorites = getFavorites(); 523 let requests = getRequests(); 524  525 // Add to graph 526  527 users.forEach(function(user) { 528   graph.createNode('user', user); 529 }); 530  531 listings.forEach(function(listing) { 532   graph.createNode('listing', listing); 533 }); 534  535 views.forEach(function(view) { 536   graph.createEdge('view').link( 537     graph.nodes('user').find(view.user_id), 538     graph.nodes('listing').find(view.listing_id) 539   ).setDistance(4); 540 }); 541  542 favorites.forEach(function(favorite) { 543   graph.createEdge('favorite').link( 544     graph.nodes('user').find(favorite.user_id), 545     graph.nodes('listing').find(favorite.listing_id) 546   ).setDistance(2); 547 }); 548  549 requests.forEach(function(request) { 550   graph.createEdge('request').link( 551     graph.nodes('user').find(request.user_id), 552     graph.nodes('listing').find(request.listing_id) 553   ).setDistance(1); 554 }); 555  556 // save graph 557 graph.save('/path_to_saved_graph.ugd', function() { 558    559   doAfterSave(); // do whatever you'd like. 560    561 }); 562  563 /* 564 * 565 querying for the 100 closest listings to a user on the graph: 566 * 567 * 568 / 569 let ug = require('ug'); 570  571 let graph = new ug.Graph(); 572  573 // load graph from flatfile into RAM 574 graph.load('/path_to_saved_graph.ugd', function() { 575  576   // get the closest 100 'listings' nodes, at a minimum depth (distance) of 3 577   let results = graph.closest(node, { 578     compare: function(node) { return node.entity === 'listing'; }, 579     minDepth: 3, 580     count: 100 581   }); 582    583   // results is now an array of Paths, which are each traces from your starting node to your result node... 584   let resultNodes = result.map(function(path) { 585     return path.end(); 586   })); 587    588   doSomething(resultNodes); // render, whatever you'd like 589    590 }); 591 /* 592 *Explanation to Students: 593  594 minDepth in the graph.closest() call is set to 3.  595 This is to prevent recommending listings to a  596 user that the user has already favorited or  597 requested (distances of 1 and 2, respectively).  598 A distance of at least 3 guarantees we’ll only  599 be recommending listings to users that they’ve  600 at least already viewed. 601 * 602 * 603 see: 604 https://medium.com/@keithwhor/using-graph-theory-to-build-a-simple-recommendation-engine-in-javascript-ec43394b35a3#.mr2xftppb 605 https://docs.angularjs.org/guide/concepts 606 https://github.com/keithwhor/UnitGraph 607 * 608 * 609 */  
